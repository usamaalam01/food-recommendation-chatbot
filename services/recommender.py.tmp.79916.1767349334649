import pandas as pd

def score_row(row, prefs: dict) -> float:
    score = 0.0

    for kw in prefs.get("keywords", []):
        if kw in row["keyword"]:
            score += 2
        if kw in row["summary"]:
            score += 1

    if prefs.get("max_cook_time"):
        score += max(
            0,
            (prefs["max_cook_time"] - row["total_time_minutes"])
            / prefs["max_cook_time"]
        )

    for ing in prefs.get("selected_ingredients", []):
        if ing in row["ingredients_list"]:
            score += 1.5

    return score

def cook_time_penalty(row, max_time):
    if not max_time or pd.isna(row["total_time_minutes"]):
        return 0

    diff = row["total_time_minutes"] - max_time
    return -max(0, diff) * 0.05   # gentle penalty


def build_query_from_prefs(prefs: dict):
    parts = []

    if prefs.get("cuisine"):
        parts.append(prefs["cuisine"])
    if prefs.get("course"):
        parts.append(prefs["course"])
    if prefs.get("keywords"):
        parts.extend(prefs["keywords"])

    return " ".join(parts)

def recommend_foods(df, preferences, semantic_ranker, top_k=5):
    query = build_query_from_prefs(preferences)

    # 1️⃣ Broad semantic retrieval
    indices, scores = semantic_ranker.rank(
        query,
        top_k=min(len(df), 100)
    )

    ranked = df.iloc[indices].copy()
    ranked["semantic_score"] = scores

    # 2️⃣ HARD filters (using substring match for flexibility)
    if preferences.get("course"):
        ranked = ranked[ranked["course"].str.contains(preferences["course"], case=False, na=False)]

    if preferences.get("cuisine"):
        ranked = ranked[ranked["cuisine"].str.contains(preferences["cuisine"], case=False, na=False)]

    if ranked.empty:
        return ranked, False

    # 3️⃣ Ingredient filtering - try strict first, then relax
    selected_ingredients = preferences.get("selected_ingredients", [])
    ingredients_relaxed = False

    if selected_ingredients:
        # Check if any selected ingredient is in ingredients_list or ingredients_text
        def has_ingredient(row):
            ingredients_text = str(row.get("ingredients_text", "")).lower()
            ingredients_list = row.get("ingredients_list", [])
            for ing in selected_ingredients:
                ing_lower = ing.lower()
                if ing_lower in ingredients_text or any(ing_lower in item.lower() for item in ingredients_list):
                    return True
            return False

        strict_filtered = ranked[ranked.apply(has_ingredient, axis=1)]

        if not strict_filtered.empty:
            ranked = strict_filtered
        else:
            # No recipes with selected ingredients, mark as relaxed
            ingredients_relaxed = True

    # 4️⃣ Keyword filtering - try strict first, then relax
    keywords = preferences.get("keywords", [])
    keywords_relaxed = False

    if keywords and not ingredients_relaxed:
        # Check if any keyword is in name, summary, keyword, or ingredients
        def has_keyword(row):
            searchable = (
                str(row.get("name", "")).lower() + " " +
                str(row.get("summary", "")).lower() + " " +
                str(row.get("keyword", "")).lower() + " " +
                str(row.get("ingredients_text", "")).lower()
            )
            for kw in keywords:
                if kw.lower() in searchable:
                    return True
            return False

        strict_filtered = ranked[ranked.apply(has_keyword, axis=1)]

        if not strict_filtered.empty:
            ranked = strict_filtered
        else:
            keywords_relaxed = True

    if ranked.empty:
        return ranked, False

    # 5️⃣ Cook time handling - try strict first, then progressively relax
    max_time = preferences.get("max_cook_time")
    time_relaxed = False

    if max_time:
        # First try: strict filter with 20% buffer
        time_tolerance = max_time * 1.2
        strict_filtered = ranked[ranked["total_time_minutes"] <= time_tolerance]

        if not strict_filtered.empty:
            ranked = strict_filtered
        else:
            # Second try: double the requested time
            relaxed_tolerance = max_time * 2
            relaxed_filtered = ranked[ranked["total_time_minutes"] <= relaxed_tolerance]

            if not relaxed_filtered.empty:
                ranked = relaxed_filtered
                time_relaxed = True
            else:
                # Third try: triple the requested time (max reasonable)
                max_reasonable = max_time * 3
                reasonable_filtered = ranked[ranked["total_time_minutes"] <= max_reasonable]

                if not reasonable_filtered.empty:
                    ranked = reasonable_filtered
                    time_relaxed = True
                else:
                    # Last resort: just mark as relaxed, will show closest by score
                    time_relaxed = True

    # Soft cook time scoring - heavily penalize recipes far from requested time
    def cook_time_bonus(row):
        if not max_time or pd.isna(row["total_time_minutes"]):
            return 0.0
        diff = row["total_time_minutes"] - max_time
        if diff <= 0:
            return 0.5  # Bonus for being under time
        # Stronger penalty for being over time
        return -min(diff / max_time, 5.0)  # Cap penalty at 5x

    ranked["final_score"] = (
        ranked["semantic_score"]
        + ranked.apply(lambda r: score_row(r, preferences), axis=1)
        + ranked.apply(cook_time_bonus, axis=1)
    )

    ranked = ranked.sort_values("final_score", ascending=False)

    # 6️⃣ Pagination
    offset = preferences.get("offset", 0)

    # Return relaxed status (any constraint was relaxed)
    any_relaxed = time_relaxed or ingredients_relaxed or keywords_relaxed
    return ranked.iloc[offset : offset + top_k], any_relaxed
